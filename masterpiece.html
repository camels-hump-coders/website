<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MASTERPIECE: Museum Detective - Camels Hump Coders</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Iceberg&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Load PointerLockControls directly
        window.addEventListener('load', () => {
            if (!THREE.PointerLockControls) {
                // Define PointerLockControls if not loaded
                console.log('Manually loading PointerLockControls...');
                
                // Simple PointerLockControls implementation
                THREE.PointerLockControls = function(camera, domElement) {
                    this.camera = camera;
                    this.domElement = domElement || document.body;
                    this.isLocked = false;
                    
                    const scope = this;
                    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                    const vector = new THREE.Vector3();
                    const PI_2 = Math.PI / 2;
                    
                    function onMouseMove(event) {
                        if (scope.isLocked === false) return;
                        
                        const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                        const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                        
                        euler.setFromQuaternion(camera.quaternion);
                        euler.y -= movementX * 0.002;
                        euler.x -= movementY * 0.002;
                        euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                        
                        camera.quaternion.setFromEuler(euler);
                    }
                    
                    function onPointerlockChange() {
                        if (scope.domElement.ownerDocument.pointerLockElement === scope.domElement) {
                            scope.dispatchEvent({type: 'lock'});
                            scope.isLocked = true;
                        } else {
                            scope.dispatchEvent({type: 'unlock'});
                            scope.isLocked = false;
                        }
                    }
                    
                    this.connect = function() {
                        document.addEventListener('mousemove', onMouseMove, false);
                        document.addEventListener('pointerlockchange', onPointerlockChange, false);
                    };
                    
                    this.disconnect = function() {
                        document.removeEventListener('mousemove', onMouseMove, false);
                        document.removeEventListener('pointerlockchange', onPointerlockChange, false);
                    };
                    
                    this.lock = function() {
                        this.domElement.requestPointerLock();
                    };
                    
                    this.unlock = function() {
                        document.exitPointerLock();
                    };
                    
                    this.getObject = function() {
                        return camera;
                    };
                    
                    this.connect();
                };
                
                THREE.PointerLockControls.prototype = Object.create(THREE.EventDispatcher.prototype);
                THREE.PointerLockControls.prototype.constructor = THREE.PointerLockControls;
                
                console.log('✅ PointerLockControls manually loaded');
            }
        });
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .hud-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Iceberg', cursive;
            border: 2px solid #FFD700;
            pointer-events: auto;
            max-width: 300px;
        }

        .investigation-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #FF6B6B;
            pointer-events: auto;
            max-width: 250px;
        }

        .controls-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4ECDC4;
            pointer-events: auto;
        }

        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        .crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        .crosshair::after {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }

        .interaction-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 215, 0, 0.9);
            color: black;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            display: none;
            pointer-events: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 0.6; }
        }

        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 2000;
            font-family: 'Iceberg', cursive;
        }

        .start-button {
            padding: 15px 30px;
            font-size: 18px;
            background: linear-gradient(135deg, rgb(115, 67, 50), rgb(204, 67, 49));
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(204, 67, 49, 0.4);
        }

        .clue-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #FFD700;
            max-width: 500px;
            z-index: 1500;
            display: none;
            pointer-events: auto;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1400;
            display: none;
        }

        .close-btn {
            background: #666;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
        }

        .clue-list {
            list-style: none;
            padding: 0;
        }

        .clue-list li {
            padding: 8px;
            margin: 5px 0;
            background: rgba(76, 175, 80, 0.2);
            border-left: 4px solid #4CAF50;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-container">
            <h1 class="site-title">Camels Hump Coders</h1>
            <p class="tagline">FIRST® LEGO® League Team from Huntington, Vermont</p>
        </div>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li class="dropdown">
                    <a href="about.html">About Us</a>
                    <ul class="dropdown-menu">
                        <li><a href="2024-2025.html">2024-2025</a></li>
                        <li><a href="2023-2024.html">2023-2024</a></li>
                    </ul>
                </li>
                <li><a href="coders.html">Coders</a></li>
                <li class="dropdown">
                    <a href="#">Games</a>
                    <ul class="dropdown-menu">
                        <li><a href="unearthed.html">Unearthed</a></li>
                        <li><a href="submerged.html">Submerged</a></li>
                        <li><a href="masterpiece.html" class="active">Masterpiece</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    </header>

    <div class="start-screen" id="startScreen">
        <h1>🏛️ MASTERPIECE: Museum Detective 🕵️</h1>
        <h2>The Case of the Missing Mona Lisa</h2>
        <p style="max-width: 600px; line-height: 1.6;">
            You are a detective investigating the theft of the famous Mona Lisa from the museum. 
            Explore the 3D museum environment in first person, search for clues, and solve the mystery!
        </p>
        <p><strong>Controls:</strong></p>
        <p>WASD - Move around | Mouse - Look around | Click - Interact with objects</p>
        <p><strong>⚠️ Important:</strong> After entering, look for the yellow "CLICK HERE TO ACTIVATE MOVEMENT" button in the bottom left and click it to enable mouse controls!</p>
        <p><small>Alternative: Use WASD to move and Arrow keys to look around if mouse controls don't work</small></p>
        <button class="start-button" onclick="startGame()">Enter the Museum</button>
        <div id="loadingIndicator" style="display: none; margin-top: 20px;">
            <p>Loading museum... Please wait.</p>
            <div style="width: 200px; height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; margin: 10px auto;">
                <div style="width: 0%; height: 100%; background: #FFD700; border-radius: 2px; animation: loading 3s ease-in-out infinite;" id="loadingBar"></div>
            </div>
        </div>
    </div>

    <style>
        @keyframes loading {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }
    </style>

    <div class="game-container" id="gameContainer">
        <div class="ui-overlay">
            <div class="hud-panel">
                <h3>🕵️ Detective Case File</h3>
                <p><strong>Mission:</strong> Find the stolen Mona Lisa</p>
                <p><strong>Clues Found:</strong> <span id="cluesFound">0</span>/8</p>
                <p><strong>Status:</strong> <span id="caseStatus">Investigating</span></p>
                <button onclick="showClues()" style="background: #4CAF50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; margin-top: 10px;">View Clues</button>
            </div>

            <div class="investigation-panel">
                <h3>🎨 Museum Security Report</h3>
                <p><strong>Missing:</strong> Mona Lisa by Leonardo da Vinci</p>
                <p><strong>Last Seen:</strong> Gallery Room 1</p>
                <p><strong>Time of Theft:</strong> Between 2-4 AM</p>
                <p id="latestClue" style="color: #FFD700; font-weight: bold;">Search for evidence...</p>
            </div>

            <div class="controls-panel">
                <h3>🎮 Controls</h3>
                <p><strong>WASD</strong> - Move</p>
                <p><strong>Mouse</strong> - Look around</p>
                <p><strong>Click</strong> - Interact with clues</p>
                <p><strong>ESC</strong> - Exit first-person mode</p>
                <div style="background: #2196F3; color: white; padding: 8px; margin-top: 10px; border-radius: 5px; text-align: center; font-size: 12px;">
                    Click anywhere to enter first-person mode
                </div>
            </div>

            <div class="crosshair"></div>
            <div class="interaction-hint" id="interactionHint">Press CLICK to investigate</div>
        </div>
    </div>

    <!-- Clue Modal -->
    <div class="modal-overlay" id="modalOverlay" onclick="closeModal()"></div>
    <div class="clue-modal" id="clueModal">
        <h3>🔍 Evidence Collected</h3>
        <ul class="clue-list" id="clueList">
        </ul>
        <button class="close-btn" onclick="closeModal()">Close</button>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let gameStarted = false;
        let cluesFound = 0;
        let discoveredClues = [];
        let interactionTarget = null;
        let raycaster, mouse;
        
        // Collision detection arrays
        let collisionObjects = [];
        let walls = [];
        let furniture = [];

        // Game state
        const gameState = {
            cluesFound: 0,
            totalClues: 8,
            caseComplete: false
        };

        // Clue definitions (positioned throughout the multi-room museum)
        const clues = {
            footprint1: {
                name: "Muddy Footprint",
                description: "A size 10 boot print with distinctive tread pattern near the Mona Lisa's frame. The mud appears fresh and contains traces of garden soil.",
                position: { x: -1, y: 0.1, z: -10.5 } // Near Mona Lisa frame
            },
            scratches: {
                name: "Wall Scratches", 
                description: "Fresh scratches on the wall where the frame was removed. The marks suggest the use of a crowbar or similar tool.",
                position: { x: -2, y: 2, z: -11.7 } // On wall behind Mona Lisa
            },
            droplet: {
                name: "Paint Droplet",
                description: "A small droplet of white paint on the floor, likely from touching the frame while it was still wet from recent restoration.",
                position: { x: 1.5, y: 0.1, z: -9 } // Main gallery floor
            },
            fabric: {
                name: "Torn Fabric",
                description: "A small piece of dark fabric caught on a security camera mount. Appears to be from a maintenance worker's uniform.",
                position: { x: 0, y: 3.5, z: 6 } // Entrance hall ceiling mount
            },
            keycard: {
                name: "Access Keycard",
                description: "A staff keycard found behind a plant. Belongs to 'J. Smith' from the maintenance department. Last used at 2:47 AM.",
                position: { x: -8.2, y: 0.5, z: 10 } // Behind plant in entrance
            },
            glove: {
                name: "Latex Glove",
                description: "A single latex glove found in the trash bin. No fingerprints inside, but contains traces of the frame's gold gilding.",
                position: { x: -19, y: 0.3, z: -3 } // Security office trash bin
            },
            note: {
                name: "Cryptic Note",
                description: "A hastily written note that reads: 'The smile will see the sunrise from the east wing storage.' Written in pencil on museum stationary.",
                position: { x: -20.2, y: 1, z: -2 } // On security desk
            },
            camera: {
                name: "Security Camera Footage",
                description: "Timestamp shows camera was disabled at 2:15 AM. Last frame shows a figure in maintenance clothes approaching the Mona Lisa.",
                position: { x: 16, y: 4, z: -3 } // East wing security camera
            }
        };

        function startGame() {
            try {
                console.log('Starting game...');
                
                // Show loading indicator
                document.getElementById('loadingIndicator').style.display = 'block';
                
                // Check if Three.js is loaded
                if (typeof THREE === 'undefined') {
                    document.getElementById('loadingIndicator').style.display = 'none';
                    console.error('Three.js library failed to load');
                    return;
                }
                
                console.log('Three.js loaded successfully');
                console.log('THREE object keys:', Object.keys(THREE));
                console.log('PointerLockControls available:', typeof THREE.PointerLockControls !== 'undefined');
                
                // Check if PointerLockControls is loaded
                if (typeof THREE.PointerLockControls === 'undefined') {
                    console.warn('PointerLockControls not loaded, will use fallback controls');
                }
                
                // Give a moment for loading animation, then start
                setTimeout(() => {
                    try {
                        document.getElementById('startScreen').style.display = 'none';
                        gameStarted = true;
                        initGame();
                    } catch (error) {
                        console.error('❌ Error during game initialization from startGame():', error);
                        document.getElementById('loadingIndicator').style.display = 'none';
                        
                        // Don't show alert or reset - show error message instead
                        console.log('🔧 Showing error message instead of resetting...');
                        const loadingIndicator = document.getElementById('loadingIndicator');
                        if (loadingIndicator) {
                            loadingIndicator.innerHTML = '<p style="color: red;">Game failed to initialize: ' + error.message + '</p><p style="color: yellow;">Check browser console for details</p><button onclick="location.reload()" style="padding: 10px; margin-top: 10px;">Refresh Page</button>';
                            loadingIndicator.style.display = 'block';
                        }
                    }
                }, 500);
                
            } catch (error) {
                console.error('Error starting game:', error);
                document.getElementById('loadingIndicator').style.display = 'none';
                alert('Error starting game: ' + error.message);
                // Show start screen again
                document.getElementById('startScreen').style.display = 'flex';
            }
        }

        function initGame() {
            try {
                console.log('Initializing game...');
                
                // Initialize Three.js scene with detailed error checking
                console.log('Creating Three.js scene...');
                if (typeof THREE.Scene !== 'function') {
                    throw new Error('THREE.Scene constructor not available');
                }
                scene = new THREE.Scene();
                console.log('✅ Scene created');

                console.log('Setting up fog...');
                scene.fog = new THREE.Fog(0x000000, 0.1, 50);
                console.log('✅ Fog added');

                console.log('Creating camera...');
                if (typeof THREE.PerspectiveCamera !== 'function') {
                    throw new Error('THREE.PerspectiveCamera constructor not available');
                }
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 1.6, 10);
                console.log('✅ Camera created at position:', camera.position);

                console.log('Creating WebGL renderer...');
                if (typeof THREE.WebGLRenderer !== 'function') {
                    throw new Error('THREE.WebGLRenderer constructor not available');
                }
                
                // Check WebGL support
                if (!window.WebGLRenderingContext) {
                    throw new Error('WebGL not supported by this browser');
                }
                
                renderer = new THREE.WebGLRenderer({ antialias: true });
                console.log('✅ WebGL renderer created');
                
                console.log('Setting renderer size...');
                renderer.setSize(window.innerWidth, window.innerHeight);
                console.log('✅ Renderer size set');
                
                console.log('Configuring renderer settings...');
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.setClearColor(0x1a1a1a);
                console.log('✅ Renderer configured with shadows');
                
                console.log('Finding game container...');
                const gameContainer = document.getElementById('gameContainer');
                if (!gameContainer) {
                    throw new Error('Game container element not found in DOM');
                }
                console.log('✅ Game container found');
                
                console.log('Appending renderer to container...');
                gameContainer.appendChild(renderer.domElement);
                console.log('✅ Renderer canvas added to page');

                // Skip the complex button system - just start first-person mode immediately
                console.log('🎮 Starting first-person mode immediately...');
                
                // Simple overlay that disappears after 3 seconds
                const instructionOverlay = document.createElement('div');
                instructionOverlay.id = 'instructionOverlay';
                instructionOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 9999;';
                instructionOverlay.innerHTML = `
                    <div style="background: rgba(0,0,0,0.9); color: white; padding: 40px; border-radius: 15px; text-align: center; font-size: 18px; border: 3px solid #FFD700; max-width: 500px;">
                        <h2 style="color: #FFD700; margin-top: 0;">🎮 First-Person Mode Active</h2>
                        <p><strong>WASD</strong> - Move around the museum</p>
                        <p><strong>Mouse</strong> - Look around</p>
                        <p><strong>Click</strong> - Collect clues</p>
                        <p style="color: #FFD700; margin-top: 30px;">Starting in <span id="countdown">3</span> seconds...</p>
                        <p style="font-size: 14px; color: #ccc;">You can explore the multi-room museum freely</p>
                    </div>
                `;
                document.body.appendChild(instructionOverlay);
                
                // Countdown and auto-start with pointer lock
                let countdown = 3;
                const countdownEl = document.getElementById('countdown');
                
                const countdownInterval = setInterval(() => {
                    countdown--;
                    if (countdownEl) countdownEl.textContent = countdown;
                    
                    if (countdown <= 0) {
                        clearInterval(countdownInterval);
                        
                        // Update overlay to show pointer lock activation
                        if (countdownEl && countdownEl.parentElement) {
                            countdownEl.parentElement.innerHTML = '<p style="color: #FFD700; font-size: 20px;">🖱️ Activating mouse lock...</p>';
                        }
                        
                        // Auto-activate pointer lock after countdown
                        setTimeout(() => {
                            console.log('🎮 Auto-activating pointer lock on game start...');
                            
                            // Update message to show what's happening
                            if (countdownEl && countdownEl.parentElement) {
                                countdownEl.parentElement.innerHTML = `
                                    <h2 style="color: #FFD700; margin-bottom: 30px;">🖱️ Capturing Mouse...</h2>
                                    <p style="color: #ccc; font-size: 18px;">Your mouse is now part of the game</p>
                                    <p style="color: #888; font-size: 14px;">Press ESC to release mouse control</p>
                                `;
                            } else {
                                console.log('⚠️ Countdown element or parent not found, continuing anyway...');
                            }
                            
                            // Request pointer lock immediately
                            requestPointerLockFull();
                            
                            // Hide overlay after attempting activation
                            setTimeout(() => {
                                instructionOverlay.style.display = 'none';
                                console.log('🎮 Game ready - mouse should be captured');
                            }, 1500);
                            
                        }, 500);
                    }
                }, 1000);
                
                // Set up mouse look variables
                let mouseX = 0, mouseY = 0;
                let mouseLookActive = false;

                // Create global function for button
                window.activatePointerLock = () => {
                    console.log('🎯 Button clicked! Attempting pointer lock...');
                    requestPointerLockFull();
                    
                    // Hide the overlay after clicking
                    setTimeout(() => {
                        instructionOverlay.style.display = 'none';
                    }, 500);
                };

                // Define pointer lock request function
                const requestPointerLockFull = () => {
                    console.log('🔒 Requesting full pointer lock...');
                    
                    const canvas = renderer.domElement;
                    
                    console.log('🔍 Canvas element:', canvas);
                    console.log('🔍 Available pointer lock methods:');
                    console.log('  - canvas.requestPointerLock:', typeof canvas.requestPointerLock);
                    console.log('  - canvas.mozRequestPointerLock:', typeof canvas.mozRequestPointerLock);
                    console.log('  - canvas.webkitRequestPointerLock:', typeof canvas.webkitRequestPointerLock);
                    
                    // Try the most compatible method first
                    if (canvas.requestPointerLock) {
                        console.log('🎯 Using standard requestPointerLock...');
                        try {
                            canvas.requestPointerLock();
                            console.log('✅ Standard pointer lock requested');
                        } catch (error) {
                            console.error('❌ Standard pointer lock failed:', error);
                        }
                    } else if (canvas.mozRequestPointerLock) {
                        console.log('🎯 Using Firefox mozRequestPointerLock...');
                        try {
                            canvas.mozRequestPointerLock();
                            console.log('✅ Firefox pointer lock requested');
                        } catch (error) {
                            console.error('❌ Firefox pointer lock failed:', error);
                        }
                    } else if (canvas.webkitRequestPointerLock) {
                        console.log('🎯 Using Webkit requestPointerLock...');
                        try {
                            canvas.webkitRequestPointerLock();
                            console.log('✅ Webkit pointer lock requested');
                        } catch (error) {
                            console.error('❌ Webkit pointer lock failed:', error);
                        }
                    } else {
                        console.warn('❌ No pointer lock methods available on this browser');
                        console.log('🔧 Browser may not support pointer lock API');
                    }
                    
                    // Give some time for the browser to process the request
                    setTimeout(() => {
                        const isLocked = document.pointerLockElement === canvas ||
                                        document.mozPointerLockElement === canvas ||
                                        document.webkitPointerLockElement === canvas;
                        
                        console.log('🔍 Pointer lock status after 1 second:', isLocked ? 'LOCKED' : 'NOT LOCKED');
                        
                        if (!isLocked) {
                            console.log('💡 Possible reasons pointer lock failed:');
                            console.log('  - Browser blocked the request (security policy)');
                            console.log('  - Browser doesn\'t support pointer lock');
                            console.log('  - Page is not served over HTTPS');
                            console.log('  - User denied the request');
                        }
                    }, 1000);
                };

                // Optional: Click anywhere as backup to re-activate pointer lock if needed
                renderer.domElement.addEventListener('click', () => {
                    if (!mouseLookActive) {
                        console.log('🖱️ Manual pointer lock activation...');
                        requestPointerLockFull();
                    }
                });

                // Handle pointer lock state changes
                const handlePointerLockChange = () => {
                    const locked = document.pointerLockElement === renderer.domElement ||
                                  document.pointerLockElement === document.body ||
                                  document.mozPointerLockElement === renderer.domElement ||
                                  document.mozPointerLockElement === document.body ||
                                  document.webkitPointerLockElement === renderer.domElement ||
                                  document.webkitPointerLockElement === document.body;
                    
                    if (locked) {
                        mouseLookActive = true;
                        console.log('🎉 POINTER LOCKED! Mouse is now captured - infinite movement!');
                        
                        // Show success message briefly
                        const successMsg = document.createElement('div');
                        successMsg.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 255, 0, 0.9); color: black; padding: 15px 25px; border-radius: 25px; font-weight: bold; z-index: 1000;';
                        successMsg.textContent = '🎮 Mouse locked! Press ESC to unlock';
                        document.body.appendChild(successMsg);
                        
                        setTimeout(() => {
                            if (successMsg.parentNode) successMsg.parentNode.removeChild(successMsg);
                        }, 4000);
                        
                    } else {
                        mouseLookActive = false;
                        console.log('🔓 Mouse control released');
                        
                        // Show instruction to return to game
                        const returnMsg = document.createElement('div');
                        returnMsg.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(255, 215, 0, 0.9); color: black; padding: 15px 25px; border-radius: 25px; font-weight: bold; z-index: 1000; cursor: pointer;';
                        returnMsg.textContent = '🖱️ Click to return to game';
                        returnMsg.onclick = () => {
                            requestPointerLockFull();
                            if (returnMsg.parentNode) returnMsg.parentNode.removeChild(returnMsg);
                        };
                        document.body.appendChild(returnMsg);
                        
                        setTimeout(() => {
                            if (returnMsg.parentNode) returnMsg.parentNode.removeChild(returnMsg);
                        }, 10000);
                    }
                };

                // Listen for pointer lock changes
                document.addEventListener('pointerlockchange', handlePointerLockChange);
                document.addEventListener('mozpointerlockchange', handlePointerLockChange);
                document.addEventListener('webkitpointerlockchange', handlePointerLockChange);
                
                // Mouse movement handler
                document.addEventListener('mousemove', (event) => {
                    if (mouseLookActive) {
                        const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                        const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                        
                        mouseX += movementX * 0.002;
                        mouseY += movementY * 0.002;
                        mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                        
                        camera.rotation.order = 'YXZ';
                        camera.rotation.y = -mouseX;
                        camera.rotation.x = -mouseY;
                    }
                });
                
                // ESC to release mouse control
                document.addEventListener('keydown', (event) => {
                    if (event.code === 'Escape') {
                        console.log('🔓 ESC pressed - releasing mouse control...');
                        mouseLookActive = false;
                        document.exitPointerLock && document.exitPointerLock();
                    }
                });
                
                console.log('✅ Simple first-person controls ready');

                // Raycaster for interactions
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                // Create museum environment with error handling
                console.log('Creating museum environment...');
                try {
                    createFastMuseum();
                    console.log('✅ Museum creation completed');
                } catch (museumError) {
                    console.error('❌ Museum creation failed:', museumError);
                    // Continue anyway with minimal setup
                    console.log('🔧 Attempting minimal museum setup...');
                    createMinimalMuseum();
                }

                // Movement controls
                setupMovement();

                // Click interaction
                renderer.domElement.addEventListener('click', onMouseClick);

                console.log('Game initialized successfully');
                
                // Hide loading indicator and start animation loop
                document.getElementById('loadingIndicator').style.display = 'none';
                animate();
                
            } catch (error) {
                console.error('❌ Game initialization failed:', error);
                console.error('❌ Error details:', error.message);
                console.error('❌ Error stack:', error.stack);
                
                // Hide loading indicator
                document.getElementById('loadingIndicator').style.display = 'none';
                
                // Don't reset or show alerts - just continue with emergency fallback
                console.log('🆘 Starting emergency recovery mode...');
                
                try {
                    console.log('Emergency recovery: Creating absolute basic scene...');
                    
                    if (!scene) {
                        console.log('Creating emergency scene...');
                        scene = new THREE.Scene();
                    }
                    
                    if (!camera) {
                        console.log('Creating emergency camera...');
                        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                        camera.position.set(0, 1.6, 5);
                    }
                    
                    if (!renderer) {
                        console.log('Creating emergency renderer...');
                        renderer = new THREE.WebGLRenderer({ antialias: false });
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        renderer.setClearColor(0x1a1a1a);
                        
                        const gameContainer = document.getElementById('gameContainer');
                        if (gameContainer) {
                            gameContainer.appendChild(renderer.domElement);
                            console.log('✅ Emergency renderer attached');
                        }
                    }
                    
                    // Add basic light and simple objects
                    const emergencyLight = new THREE.AmbientLight(0x404040, 1);
                    scene.add(emergencyLight);
                    console.log('✅ Emergency lighting added');
                    
                    // Try to start animation loop
                    console.log('🚀 Starting emergency animation loop...');
                    animate();
                    
                } catch (emergencyError) {
                    console.error('❌ Emergency recovery also failed:', emergencyError);
                    console.log('🆘 Game could not be initialized at all');
                    
                    // Show a simple message in the loading area instead of resetting
                    const loadingIndicator = document.getElementById('loadingIndicator');
                    if (loadingIndicator) {
                        loadingIndicator.innerHTML = '<p style="color: red;">Unable to load 3D environment. Please refresh page and try again.</p><button onclick="location.reload()" style="padding: 10px; margin-top: 10px;">Refresh Page</button>';
                        loadingIndicator.style.display = 'block';
                    }
                }
            }
        }

        function createFastMuseum() {
            console.log('🏛️ Creating full realistic multi-room museum...');
            
            try {
                console.log('Step 1: Creating textured floors...');
                createMuseumFloors();
                console.log('✅ Textured floors created');

                console.log('Step 2: Creating multi-room layout...');
                createRealMultiRoomLayout();
                console.log('✅ Multi-room walls created');

                console.log('Step 3: Creating artwork collection...');
                createArtworkInRooms();
                console.log('✅ Artwork and paintings created');

                console.log('Step 4: Creating realistic furniture...');
                createRealisticFurniture();
                console.log('✅ Realistic furniture created');

                console.log('Step 5: Creating advanced lighting...');
                createLighting();
                console.log('✅ Advanced lighting system created');

                console.log('Step 6: Creating detailed clues...');
                createClues();
                console.log('✅ Detective clues positioned');

                console.log('🎉 Full realistic multi-room museum created successfully!');
                
            } catch (error) {
                console.error('❌ Error in realistic museum creation:', error);
                console.error('Error stack:', error.stack);
                throw error;
            }
        }

        function createMinimalMuseum() {
            console.log('🔧 Creating emergency minimal fallback...');
            try {
                console.log('Emergency step 1: Creating floor...');
                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(10, 10),
                    new THREE.MeshBasicMaterial({ color: 0x8B7355 })
                );
                floor.rotation.x = -Math.PI / 2;
                scene.add(floor);
                console.log('✅ Emergency floor created');
                
                console.log('Emergency step 2: Creating light...');
                const light = new THREE.AmbientLight(0x404040, 1);
                scene.add(light);
                console.log('✅ Emergency light created');
                
                console.log('Emergency step 3: Creating clue...');
                const clue = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0xFFD700 })
                );
                clue.position.set(0, 0.5, -2);
                clue.userData = { type: 'clue', clueKey: 'clue0', name: 'Evidence' };
                scene.add(clue);
                console.log('✅ Emergency clue created');
                
                console.log('✅ Emergency minimal museum created');
            } catch (error) {
                console.error('❌ Emergency minimal museum failed:', error);
                console.log('🆘 Adding only basic light as absolute fallback...');
                try {
                    const emergencyLight = new THREE.AmbientLight(0x404040, 1);
                    scene.add(emergencyLight);
                    console.log('✅ Emergency light added');
                } catch (lightError) {
                    console.error('❌ Even emergency light failed:', lightError);
                }
            }
        }

        function createMuseumFloors() {
            // Main gallery floor (larger)
            const mainFloorGeometry = new THREE.PlaneGeometry(50, 50);
            const mainFloorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B7355,
                map: createMarbleTexture()
            });
            const mainFloor = new THREE.Mesh(mainFloorGeometry, mainFloorMaterial);
            mainFloor.rotation.x = -Math.PI / 2;
            mainFloor.receiveShadow = true;
            scene.add(mainFloor);

            // Carpet areas in specific rooms
            const carpetGeometry = new THREE.PlaneGeometry(12, 8);
            const carpetMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B0000,
                transparent: true,
                opacity: 0.8
            });
            
            // Red carpet in main Mona Lisa room
            const carpet1 = new THREE.Mesh(carpetGeometry, carpetMaterial);
            carpet1.rotation.x = -Math.PI / 2;
            carpet1.position.set(0, 0.01, -8);
            carpet1.receiveShadow = true;
            scene.add(carpet1);

            // Blue carpet in east wing
            const blueCarpetMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x000080,
                transparent: true,
                opacity: 0.8
            });
            const carpet2 = new THREE.Mesh(new THREE.PlaneGeometry(10, 6), blueCarpetMaterial);
            carpet2.rotation.x = -Math.PI / 2;
            carpet2.position.set(15, 0.01, 0);
            carpet2.receiveShadow = true;
            scene.add(carpet2);
        }

        function createMarbleTexture() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const context = canvas.getContext('2d');
            
            // Create marble-like pattern with more realistic coloring
            const gradient = context.createLinearGradient(0, 0, size, size);
            gradient.addColorStop(0, '#F5F5DC');
            gradient.addColorStop(0.3, '#E6E6E6');
            gradient.addColorStop(0.7, '#F0F0F0');
            gradient.addColorStop(1, '#F5F5DC');
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            
            // Add realistic marble veining
            context.globalCompositeOperation = 'multiply';
            for (let i = 0; i < 30; i++) {
                context.strokeStyle = `rgba(200, 200, 200, ${0.3 + Math.random() * 0.4})`;
                context.lineWidth = 1 + Math.random() * 3;
                context.beginPath();
                const startX = Math.random() * size;
                const startY = Math.random() * size;
                context.moveTo(startX, startY);
                
                // Create curvy veins
                for (let j = 0; j < 5; j++) {
                    const x = startX + (Math.random() - 0.5) * size * 0.6;
                    const y = startY + (Math.random() - 0.5) * size * 0.6;
                    context.quadraticCurveTo(
                        startX + (Math.random() - 0.5) * 100,
                        startY + (Math.random() - 0.5) * 100,
                        x, y
                    );
                }
                context.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.repeat.set(4, 4);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createWallTexture() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const context = canvas.getContext('2d');
            
            // Create subtle wall texture
            context.fillStyle = '#F8F8F8';
            context.fillRect(0, 0, size, size);
            
            // Add subtle texture pattern
            for (let i = 0; i < 100; i++) {
                context.fillStyle = `rgba(240, 240, 240, ${Math.random() * 0.3})`;
                context.fillRect(
                    Math.random() * size,
                    Math.random() * size,
                    2 + Math.random() * 4,
                    2 + Math.random() * 4
                );
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.repeat.set(2, 2);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createBumpTexture() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const context = canvas.getContext('2d');
            
            // Create bump map for wall texture
            context.fillStyle = '#808080';
            context.fillRect(0, 0, size, size);
            
            for (let i = 0; i < 50; i++) {
                const brightness = Math.random() * 50 + 100;
                context.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                context.fillRect(
                    Math.random() * size,
                    Math.random() * size,
                    3 + Math.random() * 6,
                    3 + Math.random() * 6
                );
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.repeat.set(2, 2);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createCheckerboardTexture() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const context = canvas.getContext('2d');
            
            const squareSize = 64;
            for (let i = 0; i < size; i += squareSize) {
                for (let j = 0; j < size; j += squareSize) {
                    const isEven = (i / squareSize + j / squareSize) % 2;
                    context.fillStyle = isEven ? '#A0826D' : '#8B7355';
                    context.fillRect(i, j, squareSize, squareSize);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.repeat.set(4, 4);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createRealMultiRoomLayout() {
            const wallHeight = 8;
            
            // Create realistic wall material with texture
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xF5F5DC,
                map: createWallTexture(),
                bumpMap: createBumpTexture(),
                bumpScale: 0.1,
                shininess: 10
            });

            // MAIN ENTRANCE HALL (Central area)
            // North wall of entrance hall
            const entranceNorth = new THREE.Mesh(new THREE.PlaneGeometry(20, wallHeight), wallMaterial);
            entranceNorth.position.set(0, 4, 15);
            entranceNorth.receiveShadow = true;
            entranceNorth.userData.boundingBox = new THREE.Box3(
                new THREE.Vector3(-10, 0, 14.5),
                new THREE.Vector3(10, wallHeight, 15.5)
            );
            walls.push(entranceNorth);
            scene.add(entranceNorth);

            // South wall of entrance hall  
            const entranceSouth = new THREE.Mesh(new THREE.PlaneGeometry(20, wallHeight), wallMaterial);
            entranceSouth.position.set(0, 4, -15);
            entranceSouth.rotation.y = Math.PI;
            entranceSouth.receiveShadow = true;
            scene.add(entranceSouth);

            // MAIN GALLERY ROOM (Where Mona Lisa was stolen)
            // Front wall behind Mona Lisa (with doorway)
            const frontWallLeft = new THREE.Mesh(new THREE.PlaneGeometry(6, wallHeight), wallMaterial);
            frontWallLeft.position.set(-7, 4, -12);
            frontWallLeft.receiveShadow = true;
            scene.add(frontWallLeft);

            const frontWallRight = new THREE.Mesh(new THREE.PlaneGeometry(6, wallHeight), wallMaterial);
            frontWallRight.position.set(7, 4, -12);
            frontWallRight.receiveShadow = true;
            scene.add(frontWallRight);

            // Left wall of main gallery
            const mainGalleryLeft = new THREE.Mesh(new THREE.PlaneGeometry(18, wallHeight), wallMaterial);
            mainGalleryLeft.position.set(-12, 4, -3);
            mainGalleryLeft.rotation.y = Math.PI / 2;
            mainGalleryLeft.receiveShadow = true;
            scene.add(mainGalleryLeft);

            // Right wall of main gallery (with opening to east wing)
            const mainGalleryRightTop = new THREE.Mesh(new THREE.PlaneGeometry(8, wallHeight), wallMaterial);
            mainGalleryRightTop.position.set(8, 4, -8);
            mainGalleryRightTop.rotation.y = -Math.PI / 2;
            mainGalleryRightTop.receiveShadow = true;
            scene.add(mainGalleryRightTop);

            const mainGalleryRightBottom = new THREE.Mesh(new THREE.PlaneGeometry(8, wallHeight), wallMaterial);
            mainGalleryRightBottom.position.set(8, 4, 2);
            mainGalleryRightBottom.rotation.y = -Math.PI / 2;
            mainGalleryRightBottom.receiveShadow = true;
            scene.add(mainGalleryRightBottom);

            // EAST WING (Storage and additional galleries)
            // East wing walls
            const eastWingNorth = new THREE.Mesh(new THREE.PlaneGeometry(16, wallHeight), wallMaterial);
            eastWingNorth.position.set(16, 4, -12);
            eastWingNorth.receiveShadow = true;
            scene.add(eastWingNorth);

            const eastWingSouth = new THREE.Mesh(new THREE.PlaneGeometry(16, wallHeight), wallMaterial);
            eastWingSouth.position.set(16, 4, 6);
            eastWingSouth.rotation.y = Math.PI;
            eastWingSouth.receiveShadow = true;
            scene.add(eastWingSouth);

            const eastWingEast = new THREE.Mesh(new THREE.PlaneGeometry(18, wallHeight), wallMaterial);
            eastWingEast.position.set(24, 4, -3);
            eastWingEast.rotation.y = -Math.PI / 2;
            eastWingEast.receiveShadow = true;
            scene.add(eastWingEast);

            // WEST WING (Security office and staff areas)
            const westWingNorth = new THREE.Mesh(new THREE.PlaneGeometry(16, wallHeight), wallMaterial);
            westWingNorth.position.set(-16, 4, -8);
            westWingNorth.receiveShadow = true;
            scene.add(westWingNorth);

            const westWingSouth = new THREE.Mesh(new THREE.PlaneGeometry(16, wallHeight), wallMaterial);
            westWingSouth.position.set(-16, 4, 8);
            westWingSouth.rotation.y = Math.PI;
            westWingSouth.receiveShadow = true;
            scene.add(westWingSouth);

            const westWingWest = new THREE.Mesh(new THREE.PlaneGeometry(16, wallHeight), wallMaterial);
            westWingWest.position.set(-24, 4, 0);
            westWingWest.rotation.y = Math.PI / 2;
            westWingWest.receiveShadow = true;
            scene.add(westWingWest);

            // CORRIDOR WALLS
            // Central corridor dividers
            const corridorDivider1 = new THREE.Mesh(new THREE.PlaneGeometry(6, wallHeight), wallMaterial);
            corridorDivider1.position.set(-4, 4, 8);
            corridorDivider1.receiveShadow = true;
            scene.add(corridorDivider1);

            const corridorDivider2 = new THREE.Mesh(new THREE.PlaneGeometry(6, wallHeight), wallMaterial);
            corridorDivider2.position.set(4, 4, 8);
            corridorDivider2.rotation.y = Math.PI;
            corridorDivider2.receiveShadow = true;
            scene.add(corridorDivider2);

            // Add ceiling elements for more realism
            createCeilingElements();
        }

        function createCeilingElements() {
            const ceilingMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFF0 });
            
            // Main gallery ceiling
            const mainCeiling = new THREE.Mesh(new THREE.PlaneGeometry(16, 20), ceilingMaterial);
            mainCeiling.position.set(0, 7.9, -2);
            mainCeiling.rotation.x = Math.PI / 2;
            mainCeiling.receiveShadow = true;
            scene.add(mainCeiling);

            // East wing ceiling
            const eastCeiling = new THREE.Mesh(new THREE.PlaneGeometry(16, 18), ceilingMaterial);
            eastCeiling.position.set(16, 7.9, -3);
            eastCeiling.rotation.x = Math.PI / 2;
            eastCeiling.receiveShadow = true;
            scene.add(eastCeiling);

            // West wing ceiling
            const westCeiling = new THREE.Mesh(new THREE.PlaneGeometry(16, 16), ceilingMaterial);
            westCeiling.position.set(-16, 7.9, 0);
            westCeiling.rotation.x = Math.PI / 2;
            westCeiling.receiveShadow = true;
            scene.add(westCeiling);
        }

        function createArtworkInRooms() {
            // MAIN GALLERY - Where Mona Lisa was stolen
            // Empty frame where Mona Lisa was stolen
            const frameGeometry = new THREE.BoxGeometry(2, 3, 0.2);
            const frameMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const monaFrame = new THREE.Mesh(frameGeometry, frameMaterial);
            monaFrame.position.set(0, 2.5, -11.8);
            monaFrame.castShadow = true;
            scene.add(monaFrame);

            // Empty space where painting was (dark backdrop)
            const emptySpaceGeometry = new THREE.PlaneGeometry(1.6, 2.6);
            const emptySpaceMaterial = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
            const emptySpace = new THREE.Mesh(emptySpaceGeometry, emptySpaceMaterial);
            emptySpace.position.set(0, 2.5, -11.7);
            scene.add(emptySpace);

            // Crime scene tape around the Mona Lisa area
            const tapeGeometry = new THREE.PlaneGeometry(4, 0.2);
            const tapeMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.8
            });
            const crimeTape = new THREE.Mesh(tapeGeometry, tapeMaterial);
            crimeTape.position.set(0, 1, -10.5);
            crimeTape.rotation.x = -Math.PI / 2;
            scene.add(crimeTape);

            // Distribute other famous paintings across different rooms
            createPaintingsInMainGallery();
            createPaintingsInEastWing();
            createPaintingsInWestWing();
            createEntranceArtwork();
        }

        function createPaintingsInMainGallery() {
            const paintings = [
                { name: "Starry Night", pos: [-10, 2.5, -8], color: 0x4169E1, wall: "left" },
                { name: "The Scream", pos: [-10, 2.5, 2], color: 0xFF6347, wall: "left" }
            ];

            paintings.forEach(painting => {
                createPaintingOnWall(painting.name, painting.pos, painting.color, painting.wall);
            });
        }

        function createPaintingsInEastWing() {
            const paintings = [
                { name: "Girl with Pearl", pos: [22, 2.5, -8], color: 0x483D8B, wall: "east" },
                { name: "American Gothic", pos: [16, 2.5, -10.5], color: 0x8B4513, wall: "north" },
                { name: "The Persistence", pos: [16, 2.5, 4.5], color: 0xDDA0DD, wall: "south" }
            ];

            paintings.forEach(painting => {
                createPaintingOnWall(painting.name, painting.pos, painting.color, painting.wall);
            });
        }

        function createPaintingsInWestWing() {
            const paintings = [
                { name: "Water Lilies", pos: [-22, 2.5, -4], color: 0x98FB98, wall: "west" },
                { name: "The Thinker", pos: [-16, 2.5, 6.5], color: 0x708090, wall: "south" }
            ];

            paintings.forEach(painting => {
                createPaintingOnWall(painting.name, painting.pos, painting.color, painting.wall);
            });
        }

        function createEntranceArtwork() {
            // Welcome banner in entrance
            const bannerGeometry = new THREE.PlaneGeometry(8, 1);
            const bannerMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B0000,
                transparent: true,
                opacity: 0.9
            });
            const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);
            banner.position.set(0, 6, 14.5);
            scene.add(banner);

            // Small sculptures in entrance
            for (let i = 0; i < 4; i++) {
                const sculptureGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.2);
                const sculptureMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
                const sculpture = new THREE.Mesh(sculptureGeometry, sculptureMaterial);
                sculpture.position.set(
                    (i % 2 === 0 ? -8 : 8),
                    0.6,
                    10 + (Math.floor(i / 2) * 4)
                );
                sculpture.castShadow = true;
                scene.add(sculpture);
            }
        }

        function createPaintingOnWall(name, pos, color, wall) {
            // Frame
            const frameGeometry = new THREE.BoxGeometry(1.8, 2.4, 0.15);
            const frameMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(pos[0], pos[1], pos[2]);
            frame.castShadow = true;
            
            // Painting
            const paintingGeometry = new THREE.PlaneGeometry(1.4, 2.0);
            const paintingMaterial = new THREE.MeshLambertMaterial({ color: color });
            const paintingMesh = new THREE.Mesh(paintingGeometry, paintingMaterial);
            
            // Position painting slightly in front of frame based on wall orientation
            switch(wall) {
                case 'north':
                    paintingMesh.position.set(pos[0], pos[1], pos[2] + 0.1);
                    break;
                case 'south':
                    paintingMesh.position.set(pos[0], pos[1], pos[2] - 0.1);
                    paintingMesh.rotation.y = Math.PI;
                    break;
                case 'east':
                    paintingMesh.position.set(pos[0] - 0.1, pos[1], pos[2]);
                    paintingMesh.rotation.y = Math.PI / 2;
                    break;
                case 'west':
                    paintingMesh.position.set(pos[0] + 0.1, pos[1], pos[2]);
                    paintingMesh.rotation.y = -Math.PI / 2;
                    break;
                case 'left':
                    paintingMesh.position.set(pos[0] + 0.1, pos[1], pos[2]);
                    paintingMesh.rotation.y = -Math.PI / 2;
                    break;
            }
            
            scene.add(frame);
            scene.add(paintingMesh);
        }


        function createRealisticFurniture() {
            // ENTRANCE HALL FURNITURE
            createEntranceFurniture();
            
            // MAIN GALLERY FURNITURE
            createMainGalleryFurniture();
            
            // SECURITY OFFICE (West Wing)
            createSecurityOfficeFurniture();
            
            // EAST WING STORAGE
            createStorageFurniture();
            
            // GENERAL MUSEUM DECORATIONS
            createMuseumDecorations();
        }

        function createEntranceFurniture() {
            // Information desk in entrance - rounded modern design
            const deskMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B4513,
                shininess: 30,
                specular: 0x111111
            });
            
            // Desk top (rounded corners)
            const deskTopGeometry = new THREE.CylinderGeometry(1.8, 1.8, 0.1, 16);
            deskTopGeometry.scale(1, 1, 0.8);
            const deskTop = new THREE.Mesh(deskTopGeometry, deskMaterial);
            deskTop.position.set(0, 0.8, 12);
            deskTop.castShadow = true;
            
            // Desk base
            const deskBaseGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.7, 8);
            const deskBase = new THREE.Mesh(deskBaseGeometry, deskMaterial);
            deskBase.position.set(0, 0.35, 12);
            deskBase.castShadow = true;
            
            // Add collision detection for desk
            deskTop.userData.collisionRadius = 2.0;
            collisionObjects.push(deskTop);
            
            scene.add(deskTop);
            scene.add(deskBase);

            // Entrance benches - modern curved design
            const benchMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x654321,
                shininess: 20
            });
            
            for (let i = 0; i < 2; i++) {
                // Bench seat (curved)
                const benchSeatGeometry = new THREE.CylinderGeometry(0.4, 0.4, 2, 16);
                benchSeatGeometry.rotateZ(Math.PI / 2);
                const benchSeat = new THREE.Mesh(benchSeatGeometry, benchMaterial);
                benchSeat.position.set(i === 0 ? -6 : 6, 0.4, 8);
                benchSeat.castShadow = true;
                
                // Bench legs
                for (let j = 0; j < 2; j++) {
                    const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4);
                    const leg = new THREE.Mesh(legGeometry, benchMaterial);
                    leg.position.set(
                        (i === 0 ? -6 : 6) + (j === 0 ? -0.8 : 0.8),
                        0.2,
                        8
                    );
                    leg.castShadow = true;
                    scene.add(leg);
                }
                
                // Add collision for bench
                benchSeat.userData.collisionRadius = 1.2;
                collisionObjects.push(benchSeat);
                
                scene.add(benchSeat);
            }
        }

        function createMainGalleryFurniture() {
            // Display pedestals - elegant marble-like design
            const pedestalMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xF5F5F5,
                map: createMarbleTexture(),
                shininess: 60,
                specular: 0x222222
            });
            
            const pedestalPositions = [
                [-6, 0.6, -6],
                [6, 0.6, -6],
                [-4, 0.6, 0],
                [4, 0.6, 0]
            ];

            pedestalPositions.forEach(pos => {
                // Pedestal base (wider bottom)
                const pedestalBaseGeometry = new THREE.CylinderGeometry(0.5, 0.6, 0.4);
                const pedestalBase = new THREE.Mesh(pedestalBaseGeometry, pedestalMaterial);
                pedestalBase.position.set(pos[0], 0.2, pos[2]);
                pedestalBase.castShadow = true;
                
                // Pedestal column
                const pedestalColumnGeometry = new THREE.CylinderGeometry(0.35, 0.4, 0.8);
                const pedestalColumn = new THREE.Mesh(pedestalColumnGeometry, pedestalMaterial);
                pedestalColumn.position.set(pos[0], 0.8, pos[2]);
                pedestalColumn.castShadow = true;
                
                // Pedestal top
                const pedestalTopGeometry = new THREE.CylinderGeometry(0.45, 0.4, 0.1);
                const pedestalTop = new THREE.Mesh(pedestalTopGeometry, pedestalMaterial);
                pedestalTop.position.set(pos[0], 1.25, pos[2]);
                pedestalTop.castShadow = true;
                
                // Add collision detection
                pedestalColumn.userData.collisionRadius = 0.8;
                collisionObjects.push(pedestalColumn);
                
                scene.add(pedestalBase);
                scene.add(pedestalColumn);
                scene.add(pedestalTop);
            });

            // Velvet ropes around Mona Lisa area
            createVelvetRopes();
        }

        function createVelvetRopes() {
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const ropeGeometry = new THREE.CylinderGeometry(0.02, 0.02, 3);
            const ropeMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });

            const ropePositions = [
                [-2, -10], [2, -10], [-2, -8], [2, -8]
            ];

            ropePositions.forEach(pos => {
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(pos[0], 0.5, pos[1]);
                post.castShadow = true;
                scene.add(post);
            });
        }

        function createSecurityOfficeFurniture() {
            // Security desk
            const securityDeskGeometry = new THREE.BoxGeometry(2.5, 0.8, 1.2);
            const securityDesk = new THREE.Mesh(securityDeskGeometry, new THREE.MeshLambertMaterial({ color: 0x654321 }));
            securityDesk.position.set(-20, 0.4, -2);
            securityDesk.castShadow = true;
            scene.add(securityDesk);

            // Office chair
            const chairGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.8);
            const chair = new THREE.Mesh(chairGeometry, new THREE.MeshLambertMaterial({ color: 0x000000 }));
            chair.position.set(-19, 0.4, -2);
            chair.castShadow = true;
            scene.add(chair);

            // Filing cabinet
            const filingCabinetGeometry = new THREE.BoxGeometry(0.8, 1.5, 0.6);
            const filingCabinet = new THREE.Mesh(filingCabinetGeometry, new THREE.MeshLambertMaterial({ color: 0x708090 }));
            filingCabinet.position.set(-22, 0.75, 2);
            filingCabinet.castShadow = true;
            scene.add(filingCabinet);
        }

        function createStorageFurniture() {
            // Storage crates in east wing
            for (let i = 0; i < 6; i++) {
                const crateGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                const crateMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const crate = new THREE.Mesh(crateGeometry, crateMaterial);
                crate.position.set(
                    18 + (i % 3) * 2,
                    0.6,
                    -8 + Math.floor(i / 3) * 4
                );
                crate.castShadow = true;
                scene.add(crate);
            }

            // Storage shelving
            const shelfGeometry = new THREE.BoxGeometry(4, 2.5, 0.3);
            const shelfMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
            shelf.position.set(20, 1.25, 4);
            shelf.castShadow = true;
            scene.add(shelf);
        }

        function createMuseumDecorations() {
            // Decorative plants throughout museum
            const plantPositions = [
                [-8, 0.75, 10],  // Entrance
                [8, 0.75, 10],   // Entrance
                [-15, 0.75, 5],  // West wing
                [15, 0.75, -10], // East wing
                [-5, 0.75, -3],  // Main gallery
                [5, 0.75, -3],   // Main gallery
            ];

            plantPositions.forEach(pos => {
                const plantGeometry = new THREE.ConeGeometry(0.4, 1.5, 8);
                const plantMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const plant = new THREE.Mesh(plantGeometry, plantMaterial);
                plant.position.set(pos[0], pos[1], pos[2]);
                plant.castShadow = true;
                scene.add(plant);

                // Plant pot
                const potGeometry = new THREE.CylinderGeometry(0.5, 0.4, 0.6);
                const potMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const pot = new THREE.Mesh(potGeometry, potMaterial);
                pot.position.set(pos[0], 0.3, pos[2]);
                pot.castShadow = true;
                scene.add(pot);
            });

            // Museum signage
            createMuseumSigns();
        }

        function createMuseumSigns() {
            const signGeometry = new THREE.PlaneGeometry(2, 0.8);
            const signMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9
            });

            const signs = [
                { text: "Main Gallery", pos: [0, 2, 6] },
                { text: "East Wing Storage", pos: [12, 2, -2] },
                { text: "Security Office", pos: [-12, 2, 2] }
            ];

            signs.forEach(sign => {
                const signMesh = new THREE.Mesh(signGeometry, signMaterial);
                signMesh.position.set(sign.pos[0], sign.pos[1], sign.pos[2]);
                scene.add(signMesh);
            });
        }

        function createLighting() {
            // Soft ambient light for realistic museum atmosphere
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Main directional light (simulating natural skylight)
            const mainLight = new THREE.DirectionalLight(0xFFFFEE, 0.6);
            mainLight.position.set(10, 15, 5);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 4096;
            mainLight.shadow.mapSize.height = 4096;
            mainLight.shadow.camera.near = 0.1;
            mainLight.shadow.camera.far = 100;
            mainLight.shadow.camera.left = -30;
            mainLight.shadow.camera.right = 30;
            mainLight.shadow.camera.top = 30;
            mainLight.shadow.camera.bottom = -30;
            mainLight.shadow.bias = -0.0001;
            scene.add(mainLight);

            // Dramatic spotlight on empty Mona Lisa frame
            const monaSpotlight = new THREE.SpotLight(0xFFFFFF, 1.2);
            monaSpotlight.position.set(0, 7, -5);
            monaSpotlight.target.position.set(0, 2.5, -11.8);
            monaSpotlight.angle = Math.PI / 8;
            monaSpotlight.penumbra = 0.3;
            monaSpotlight.distance = 15;
            monaSpotlight.decay = 1;
            monaSpotlight.castShadow = true;
            scene.add(monaSpotlight);
            scene.add(monaSpotlight.target);

            // Museum ceiling track lighting
            createTrackLighting();
            
            // Accent lighting for different wings
            createWingLighting();
        }

        function createTrackLighting() {
            // Main gallery track lights
            for (let i = -2; i <= 2; i++) {
                const trackLight = new THREE.SpotLight(0xFFF8DC, 0.8, 12);
                trackLight.position.set(i * 3, 6, -3);
                trackLight.target.position.set(i * 3, 0, -3);
                trackLight.angle = Math.PI / 4;
                trackLight.penumbra = 0.2;
                trackLight.decay = 1;
                scene.add(trackLight);
                scene.add(trackLight.target);
            }

            // Entrance hall lighting
            for (let i = 0; i < 3; i++) {
                const entranceLight = new THREE.PointLight(0xFFFFF0, 0.6, 8);
                entranceLight.position.set((i - 1) * 6, 5, 10);
                scene.add(entranceLight);
            }
        }

        function createWingLighting() {
            // East wing (storage area) - cooler lighting
            const eastWingLight = new THREE.PointLight(0xE6F3FF, 0.5, 15);
            eastWingLight.position.set(18, 5, -3);
            scene.add(eastWingLight);

            // West wing (security office) - warmer lighting
            const westWingLight = new THREE.PointLight(0xFFF0E6, 0.7, 12);
            westWingLight.position.set(-18, 4, 0);
            scene.add(westWingLight);

            // Corridor lighting
            for (let i = 0; i < 5; i++) {
                const corridorLight = new THREE.PointLight(0xFFFFF8, 0.4, 6);
                corridorLight.position.set((i - 2) * 4, 4, 8);
                scene.add(corridorLight);
            }
        }

        function createClues() {
            Object.keys(clues).forEach(clueKey => {
                const clue = clues[clueKey];
                let clueGeometry, clueMaterial;

                // Make all clues larger and more visible with glowing effect
                switch(clueKey) {
                    case 'footprint1':
                        clueGeometry = new THREE.PlaneGeometry(0.6, 1.0);
                        clueMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x8B4513, 
                            transparent: true, 
                            opacity: 0.9 
                        });
                        break;
                    case 'scratches':
                        clueGeometry = new THREE.PlaneGeometry(0.4, 1.5);
                        clueMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x666666,
                            emissive: 0x222222
                        });
                        break;
                    case 'droplet':
                        clueGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                        clueMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFFFF,
                            emissive: 0x444444
                        });
                        break;
                    case 'fabric':
                        clueGeometry = new THREE.PlaneGeometry(0.3, 0.3);
                        clueMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x2F2F2F,
                            emissive: 0x111111
                        });
                        break;
                    case 'keycard':
                        clueGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.5);
                        clueMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x4169E1,
                            emissive: 0x001144
                        });
                        break;
                    case 'glove':
                        clueGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                        clueMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFAF0,
                            emissive: 0x333322
                        });
                        break;
                    case 'note':
                        clueGeometry = new THREE.PlaneGeometry(0.4, 0.3);
                        clueMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFAF0,
                            emissive: 0x332211
                        });
                        break;
                    case 'camera':
                        clueGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                        clueMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x2F2F2F,
                            emissive: 0x222222
                        });
                        break;
                    default:
                        clueGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                        clueMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFD700,
                            emissive: 0x444400
                        });
                }

                const clueMesh = new THREE.Mesh(clueGeometry, clueMaterial);
                clueMesh.position.set(clue.position.x, clue.position.y, clue.position.z);
                clueMesh.userData = { type: 'clue', clueKey: clueKey };
                clueMesh.castShadow = true;

                // Add pulsing animation to make clues more visible
                clueMesh.userData.originalEmissive = clueMaterial.emissive.getHex();
                clueMesh.userData.pulseTime = Math.random() * Math.PI * 2;

                // Special positioning for wall-mounted clues
                if (clueKey === 'scratches') {
                    clueMesh.rotation.z = Math.PI / 4;
                } else if (clueKey === 'camera') {
                    clueMesh.rotation.y = Math.PI / 4;
                } else if (clueKey === 'footprint1') {
                    clueMesh.rotation.x = -Math.PI / 2;
                }

                scene.add(clueMesh);
            });
        }


        function setupMovement() {
            // Make moveState globally accessible
            window.moveState = {
                forward: false,
                backward: false,
                left: false,
                right: false
            };

            const onKeyDown = (event) => {
                switch (event.code) {
                    case 'KeyW': 
                        window.moveState.forward = true; 
                        console.log('W pressed - moving forward');
                        break;
                    case 'KeyS': 
                        window.moveState.backward = true;
                        console.log('S pressed - moving backward');
                        break;
                    case 'KeyA': 
                        window.moveState.left = true;
                        console.log('A pressed - moving left');
                        break;
                    case 'KeyD': 
                        window.moveState.right = true;
                        console.log('D pressed - moving right');
                        break;
                }
            };

            const onKeyUp = (event) => {
                switch (event.code) {
                    case 'KeyW': window.moveState.forward = false; break;
                    case 'KeyS': window.moveState.backward = false; break;
                    case 'KeyA': window.moveState.left = false; break;
                    case 'KeyD': window.moveState.right = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            console.log('Movement controls set up - WASD keys ready');
        }

        function checkCollision(newPosition) {
            const playerRadius = 0.5; // Player collision radius
            
            for (let obj of collisionObjects) {
                const distance = newPosition.distanceTo(obj.position);
                if (distance < (obj.userData.collisionRadius || 1.0) + playerRadius) {
                    return true; // Collision detected
                }
            }
            
            // Check wall boundaries
            for (let wall of walls) {
                const box = wall.userData.boundingBox;
                if (box && isPointInBox(newPosition, box, playerRadius)) {
                    return true;
                }
            }
            
            return false; // No collision
        }

        function isPointInBox(point, box, radius) {
            return (point.x + radius > box.min.x && point.x - radius < box.max.x &&
                    point.z + radius > box.min.z && point.z - radius < box.max.z);
        }

        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = 0; // Center of screen
            mouse.y = 0; // Center of screen

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            raycaster.far = 10; // Increase detection range

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(scene.children, true);

            // Also check for nearby clues within detection radius
            const playerPosition = camera.position;
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'clue') {
                    const distance = playerPosition.distanceTo(child.position);
                    if (distance < 3) { // Detection radius of 3 units
                        const clueKey = child.userData.clueKey;
                        if (!discoveredClues.includes(clueKey)) {
                            discoverClue(clueKey, child);
                        }
                    }
                }
            });

            // Original raycast detection
            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                
                if (intersectedObject.userData && intersectedObject.userData.type === 'clue') {
                    const clueKey = intersectedObject.userData.clueKey;
                    if (!discoveredClues.includes(clueKey)) {
                        discoverClue(clueKey, intersectedObject);
                    }
                }
            }
        }

        function discoverClue(clueKey, clueMesh) {
            discoveredClues.push(clueKey);
            gameState.cluesFound++;
            
            // Remove clue from scene and add glow effect
            clueMesh.material.emissive = new THREE.Color(0x00FF00);
            setTimeout(() => {
                scene.remove(clueMesh);
            }, 1000);

            // Update UI
            document.getElementById('cluesFound').textContent = gameState.cluesFound;
            document.getElementById('latestClue').textContent = `Found: ${clues[clueKey].name}`;

            // Check if case is complete
            if (gameState.cluesFound >= gameState.totalClues) {
                setTimeout(() => {
                    solveCase();
                }, 2000);
            }

            // Show notification
            showClueNotification(clues[clueKey].name);
        }

        function showClueNotification(clueName) {
            const hint = document.getElementById('interactionHint');
            hint.textContent = `🔍 Found: ${clueName}!`;
            hint.style.display = 'block';
            hint.style.background = 'rgba(76, 175, 80, 0.9)';
            
            setTimeout(() => {
                hint.style.display = 'none';
                hint.style.background = 'rgba(255, 215, 0, 0.9)';
                hint.textContent = 'Press CLICK to investigate';
            }, 3000);
        }

        function solveCase() {
            gameState.caseComplete = true;
            document.getElementById('caseStatus').textContent = '✅ SOLVED!';
            document.getElementById('latestClue').textContent = 'Case Solved! The Mona Lisa is in the east wing storage!';
            document.getElementById('latestClue').style.color = '#4CAF50';
            
            alert(`🎉 CASE SOLVED! 🎉

Detective, you've successfully gathered all the evidence!

The clues point to maintenance worker J. Smith who accessed the museum at 2:47 AM using their keycard. They disabled the security camera, used tools to remove the Mona Lisa from its frame, and left a trail of evidence.

The cryptic note reveals the painting's location: "The smile will see the sunrise from the east wing storage."

The Mona Lisa has been recovered! Excellent detective work! 🕵️‍♂️✨`);
        }

        function showClues() {
            if (discoveredClues.length === 0) {
                alert("No clues discovered yet. Explore the museum and look for suspicious items!");
                return;
            }

            const clueList = document.getElementById('clueList');
            clueList.innerHTML = '';
            
            discoveredClues.forEach(clueKey => {
                const clue = clues[clueKey];
                const li = document.createElement('li');
                li.innerHTML = `<strong>${clue.name}:</strong><br>${clue.description}`;
                clueList.appendChild(li);
            });

            document.getElementById('modalOverlay').style.display = 'block';
            document.getElementById('clueModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('modalOverlay').style.display = 'none';
            document.getElementById('clueModal').style.display = 'none';
        }

        function animate() {
            requestAnimationFrame(animate);

            // Animate clue pulsing effect
            const time = Date.now() * 0.003;
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'clue' && child.material) {
                    child.userData.pulseTime += 0.05;
                    const pulseIntensity = (Math.sin(child.userData.pulseTime) + 1) * 0.5;
                    const baseEmissive = child.userData.originalEmissive;
                    child.material.emissive.setHex(baseEmissive);
                    child.material.emissive.multiplyScalar(0.5 + pulseIntensity * 0.8);
                }
            });

            // First-person movement with camera direction
            if (gameStarted && window.moveState) {
                const speed = 0.1;
                
                // Get forward and right vectors based on camera rotation
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                const up = new THREE.Vector3(0, 1, 0);
                
                camera.getWorldDirection(forward);
                forward.y = 0; // Keep movement horizontal
                forward.normalize();
                
                right.crossVectors(forward, up);
                right.normalize();
                
                // Apply movement based on input
                if (window.moveState.forward) {
                    camera.position.add(forward.clone().multiplyScalar(speed));
                }
                if (window.moveState.backward) {
                    camera.position.add(forward.clone().multiplyScalar(-speed));
                }
                if (window.moveState.left) {
                    camera.position.add(right.clone().multiplyScalar(-speed));
                }
                if (window.moveState.right) {
                    camera.position.add(right.clone().multiplyScalar(speed));
                }

                // Keep camera at eye level and within museum bounds
                camera.position.y = 1.6;
                camera.position.x = Math.max(-23, Math.min(23, camera.position.x));
                camera.position.z = Math.max(-14, Math.min(14, camera.position.z));
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>